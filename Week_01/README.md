学习笔记

# 数组
- 访问: 数组下标直接索引,时间复杂度O(1)
- 存储: 线性连续存储

## 1. 两数之和(leetcode 1)
> 方法一: 第二目标数 = target - nums[i]
- 使用一个map 存储 key为数组值 value为下标，遍历数组,遍历的过程中记录第二个目标值对应的下标
- 时间复杂度:O(n)
- 空间复杂度:O(n)

> 方法二: nums[i] + nums[j] = target
- 两层遍历
- 时间复杂度O(n2)
- 空间复杂度O(1)

## 2. 加一(letetcode 66)
> 方法一: 每次取模进位
- 一层遍历，加一取模为进位，取整为该位重新赋值，最后判断是否有进位，进位则重新生成数组
- 时间复杂度O(n)
- 空间复杂度O(n)

> 方法二: 巧妙通过9 判断是否进位
- 一层遍历，首先判断该位置是否为9,如果不是则加一 return,如果是则置为0,继续循环
- 时间复杂度O(n)
- 空间复杂度O(n)

## 3. 移动零 (leetcode 289)
> 方法一: 把当前数放在，该放置在下一个的非0位置
- 一层遍历
- 时间复杂度O(n)

> 方法二: 记录当前非0元素个数，同时这个个数也是下一个非0元素该放置的位置
- 一层遍历
- 时间复杂度O(n)

## 4. 两两交换链表中的节点 (leetcode 24)
> 方法一: 递归 先交换前面两个，然后后面所有的交换，把后面的head 放到前面已经交换好的后面
- 递归
- 时间复杂度O(n)

> 方法二: 每两个元素为一组，先交换着两个 ，然后继续交换后面两个，其中为了和前面的两个联系起来设置一个pre
- 循环迭代
- 时间复杂度O(n)

## 5. 合并两个有序链表 (leetcode 21)
> 方法一: 新起一个链表，让l1和l2 中较小的作为新链表的头，然后后移一个，
然后遍历两个链表的头，取较小的插入到新链表的尾部，依次移动指针迭代

- 循环迭代
- 时间复杂度O(n)
